\documentclass{article}

\usepackage {titlesec}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}

% Offset setup %
\usepackage[left=15mm,
            top=15mm, 
            right=10mm,
            bottom=15mm, nohead, nofoot]{geometry}

% Maths packages %
\usepackage{amssymb}
\usepackage{amsmath}

% Special symbols %
\usepackage{wasysym}
\usepackage{cancel}
\usepackage{graphicx}
\usepackage{numprint}

\graphicspath{{pictures/}}

\titlespacing*{\section}{\parindent}{*4}{*4}



\title{Домашнее задание 20}
\author{Ткачев Андрей, группа 166}
\date{\today}

% Other%
\newcommand{\pr}{^{\prime}}
\newcommand{\ppr}{^{\prime\prime}}
\newcommand{\xp}{x^{\prime}}
\newcommand{\xpp}{x^{\prime\prime}}
\newcommand{\xppp}{x^{\prime\prime\prime}}
% Alias %
\newcommand{\pair}[2]{(#1,\ #2)}
\newcommand{\andi}{$ и $}
\newcommand{\xor}{\oplus}
%\newcommand{\xor}{\oplus}%

% Fracs %
\newcommand{\half}[1]{\frac{#1}{2}}
% Pretty Num letters%
\newcommand{\N}{\mathbb{N}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\M}{\mathbb{M}}
\newcommand{\conti}{2^{\N}}

% Vector graphics %
\usepackage{tikz}
\definecolor{white}{rgb}{1.0, 1.0, 1.0}
\definecolor{black}{rgb}{0.0, 0.0, 0.0}
\definecolor{royalblue}{RGB}{255,170,128}
\definecolor{lgr}{RGB}{168, 228, 160}
\definecolor{lblue}{RGB}{24,205,255}

\usetikzlibrary{decorations.markings}
\usetikzlibrary{shapes.geometric}

\pgfdeclarelayer{edgelayer}
\pgfdeclarelayer{nodelayer}
\pgfsetlayers{edgelayer,nodelayer,main}

\tikzstyle{none}=[inner sep=0pt]
\tikzstyle{node}=[circle,fill=white,draw=black,thick]

% Pretty algorithm %
%\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage[linesnumbered,boxed]{algorithm2e}


\begin{document}
    \maketitle
    \paragraph{Задача 1.}
    \textbf{(а)} Да, верно. Перечислимо $\N$, и вычислимы $\pi(i), \pi(i + 1), \ldots, \pi(i + 4)$ $\Rightarrow$ перечислитель всех наборов подряд идущих цифр числа $\pi$ длины 5 может для каждого перечисленного $i \in \N$ вывести $\pi(i), \pi(i + 1), \ldots, \pi(i + 4)$. Так как каждая последовательность из множества последовательностей входящих в $\pi$ входит в $\pi$ с некоторой позиции $i$, то на $i$-ой иттерации перечислителя эта последовательность будет выведена. И наоборот, если какая-то последовательность выведена, то она содержится в $\pi$ и ее длина 5.

     \textbf{(б)} Да, верно. Множество всех последовательностей цифр длины 5 конечно (содержит $10^5$ элментов), а значит множество последовательностей длины 5, входящих в $\pi$ является подмножеством конечного множества, а значит конечно $\Rightarrow$ разрешимо.

     \paragraph{Задача 2.} Заметим, что функция $didgitSum(n): \N \rightarrow \N$ вычислима и всюду определена (для каждого входа, выдает результат за конечное число шагов). Тогда приведем пример перечислителя чисел из $X$, сумма цифр которых равна 10.
     
     \begin{algorithm}[H]
        \SetAlgoLined %% Это соединяет линиями логические части 
        % \KwData{} % здесь можно указать исходные параметры
        % \KwResult{} % результат работы программы
        \For{ $x \in X$ }{
            \If{$didgitSum(x) = 10$}{
                $print(x)$;
            }
        }
        \caption{Enumerante Y}
    \end{algorithm}

    Так как каждый элемент $X$ будет перечислен, то для каждого из них будет вычислена сумма цифр, то каждое число из $Y$ будет выведено.

    \paragraph{Задача 3.} Будем считать, что мы обладаем неограниченным объемом памяти. $A$ и $B$ перечислимы, значит существуют алгоритмы, их перечисляющие. Составим перечислитель $A\times B$. Вывод каждого из перечислителей будем записывать в один из массивов --- массив $A_{out}$ и массив для $B_{out}$ (т.е. вместо команды печати будет команда записи в массив). Будем выполнять по-очередно шаги этих перечислителей. После очередного выполненного шага будем выводить все попарные сочетания элементов из массива $A_{out}$ и из массива $B_{out}$ (так, чтобы элементы из $A$ были первыми в паре). Таким образом,для любой пары $(a, b) \in A \times B$ верно, что одно из чисел $a, b$ будет добавленно в соответствующий массив раньше другого, так как будет перечислено соответсвующим перечислителем, и после шага, на котором перечисляется второе число из пары другим перечислителем, в массивах будут оба числа $a, b$, значит будет выведена пара $(a, b)$, т.е. все пары из $A \times B$ будут перечислены. Более того, очевидно, что перечисляются только парвы вида $(a, b)$, $a \in A,\ b \in B$, значит полученный перечислитель перечисляет ровно $A \times B$.

    \paragraph{Задача 4.} Пусть $E(f(x)) = \N \setminus M$. Если $M$ --- пустое множество, то $f(x) = id_{\N}$, очевидно вычислимая функция. Иначе, пусть $x_0 = sup\ M$ ($M$ конечно, значит точная верхняя грань существует). Поймем, что $\forall x \ge x_0: f(x) = f(x_0) + x - x_0$ ($f(x)$ --- строго возрастает, и начиная с $x_0$ содержит все натуральные числа, большие $f(x_0)$, т.е. значения функции на соседних аргументах --- последовательные натуральные числа). Множество $M$ конечно, значит $\forall x\pr \in M $ можно запомнить $f(x\pr)$. Таким образом вычисление $f(x)$ сводится к проверке неравенства $x \ge x_0$, и в случае истинны результат --- приведенная выше формула, в противном случае ответ --- одно из извествных значений $f(x)$ на некотором конечном множестве, т.е. вычислимый ответ. Таким образом, $f(x)$ --- вычислима.

    \paragraph{Задача 5.} Мы знаем, что существует неразрешимое множество $Y \in N$ (т.к. число алгооримов счетно, а подмножеств натуральных чисел --- континуум). Мы так же знаем, что $X = \N$ --- разрешимое множество (его характеристическая функция --- константа, равная 1). Но $X \cup Y = \N \cup Y = \N \Rightarrow X \cup Y$ --- разрешимо. Однако, по праву выбора --- $Y$ не разрешимо.

    \textbf{Ответ:} Да, существуют. Например,  $X = \N$, а $Y $ --- любое неразрешимое множество.

    \paragraph{Задача 6.}
    Мы знаем, что функция $isPrime(x)$, равная 1, если $x $ --- простое, и 0 в противном случае, --- вычислима и всюду определена(для любого $x$ можно за $x^{\frac{1}{2}}$ операций выяснить простоту --- простым перебором чисел от 2 до корня и проверкой $x$ на делимость: $x$ --- не просто, если одно из чисел на отрезке $[2, \lfloor \sqrt{x} \rfloor]$ является делителем $x$). Множество $S$ разрешимо, значит перечислимо. Таким образом, можно предоставить алгоритм, перечисляющий элементы $D$:

    \begin{algorithm}[H]
        \SetAlgoLined %% Это соединяет линиями логические части 
        % \KwData{} % здесь можно указать исходные параметры
        % \KwResult{} % результат работы программы

        \For{ $x \in S$ }{
            \For { $x_0 \le x$} {
                \If{$isPrime(x_0)$}{
                    $print(x_0)$;
                }
            }
        }
        \caption{Enumerante D}
    \end{algorithm}

    Данный алгоритм действительно печатает только простые числа, которые являются делителями какого-то из чисел в $S$, причем кажыдый такой простой делитель будет распечатан, т.к. перечислитель $S$ перечисляет все числа в $S$, а функция проверки на простоту вычислима.

    \paragraph{Задача 7.}
    Приведем алгоритм вычисления $f^{-1}$:

        \begin{algorithm}[H]
         \KwData{y}
         \KwResult{$f^{-1}(y)$}
        \SetAlgoLined %% Это соединяет линиями логические части 
        % \KwData{} % здесь можно указать исходные параметры
        % \KwResult{} % результат работы программы

        \For{ $x \in \N$ }{
            \If {$y = f(x)$} {
                 print(x);
                 break;
            }
        }
        \caption{Compute $f^{-1}$}
    \end{algorithm}

    Так как $f$ --- биекция, то $\forall y \in \N\ \exists x \in \N: f(y) = x$, причем $y = f^{-1}(x)$. Таким образом, т.к. $\N$ --- перечислимое множество, а $f(x)$ --- вычислима, то за конечное число иттераций для конкретного $y$ будет найден $x:\ f(x) = y$, которой и будет равен $f^{-1}(y)$.

   
\end{document}